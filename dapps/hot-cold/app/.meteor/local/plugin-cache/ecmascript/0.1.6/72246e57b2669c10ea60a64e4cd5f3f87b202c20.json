{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"var url = Npm.require('url');\n\n// By default, we use the permessage-deflate extension with default\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid\n// JSON. If it represents a falsey value, then we do not use permessage-deflate\n// at all; otherwise, the JSON value is used as an argument to deflate's\n// configure method; see\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md\n//\n// (We do this in an _.once instead of at startup, because we don't want to\n// crash the tool during isopacket load if your JSON doesn't parse. This is only\n// a problem because the tool has to load the DDP server code just in order to\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)\nvar websocketExtensions = _.once(function () {\n  var extensions = [];\n\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {\n    extensions.push(Npm.require('permessage-deflate').configure(websocketCompressionConfig));\n  }\n\n  return extensions;\n});\n\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\";\n\nStreamServer = function () {\n  var self = this;\n  self.registration_callbacks = [];\n  self.open_sockets = [];\n\n  // Because we are installing directly onto WebApp.httpServer instead of using\n  // WebApp.app, we have to process the path prefix ourselves.\n  self.prefix = pathPrefix + '/sockjs';\n  RoutePolicy.declare(self.prefix + '/', 'network');\n\n  // set up sockjs\n  var sockjs = Npm.require('sockjs');\n  var serverOptions = {\n    prefix: self.prefix,\n    log: function () {},\n    // this is the default, but we code it explicitly because we depend\n    // on it in stream_client:HEARTBEAT_TIMEOUT\n    heartbeat_delay: 45000,\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\n    // bound for that much time, SockJS might not notice that the user has\n    // reconnected because the timer (of disconnect_delay ms) can fire before\n    // SockJS processes the new connection. Eventually we'll fix this by not\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\n    // converts to Unix sockets) but for now, raise the delay.\n    disconnect_delay: 60 * 1000,\n    // Set the USE_JSESSIONID environment variable to enable setting the\n    // JSESSIONID cookie. This is useful for setting up proxies with\n    // session affinity.\n    jsessionid: !!process.env.USE_JSESSIONID\n  };\n\n  // If you know your server environment (eg, proxies) will prevent websockets\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\n  // browsers) will not waste time attempting to use them.\n  // (Your server will still have a /websocket endpoint.)\n  if (process.env.DISABLE_WEBSOCKETS) {\n    serverOptions.websocket = false;\n  } else {\n    serverOptions.faye_server_options = {\n      extensions: websocketExtensions()\n    };\n  }\n\n  self.server = sockjs.createServer(serverOptions);\n\n  // Install the sockjs handlers, but we want to keep around our own particular\n  // request handler that adjusts idle timeouts while we have an outstanding\n  // request.  This compensates for the fact that sockjs removes all listeners\n  // for \"request\" to add its own.\n  WebApp.httpServer.removeListener('request', WebApp._timeoutAdjustmentRequestCallback);\n  self.server.installHandlers(WebApp.httpServer);\n  WebApp.httpServer.addListener('request', WebApp._timeoutAdjustmentRequestCallback);\n\n  // Support the /websocket endpoint\n  self._redirectWebsocketEndpoint();\n\n  self.server.on('connection', function (socket) {\n    socket.send = function (data) {\n      socket.write(data);\n    };\n    socket.on('close', function () {\n      self.open_sockets = _.without(self.open_sockets, socket);\n    });\n    self.open_sockets.push(socket);\n\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which\n    // will force old clients to reload. Remove this once we're not\n    // concerned about people upgrading from a pre-0.7.0 release. Also,\n    // remove the clause in the client that ignores the welcome message\n    // (livedata_connection.js)\n    socket.send(JSON.stringify({ server_id: \"0\" }));\n\n    // call all our callbacks when we get a new socket. they will do the\n    // work of setting up handlers and such for specific messages.\n    _.each(self.registration_callbacks, function (callback) {\n      callback(socket);\n    });\n  });\n};\n\n_.extend(StreamServer.prototype, {\n  // call my callback when a new socket connects.\n  // also call it for all current connections.\n  register: function (callback) {\n    var self = this;\n    self.registration_callbacks.push(callback);\n    _.each(self.all_sockets(), function (socket) {\n      callback(socket);\n    });\n  },\n\n  // get a list of all sockets\n  all_sockets: function () {\n    var self = this;\n    return _.values(self.open_sockets);\n  },\n\n  // Redirect /websocket to /sockjs/websocket in order to not expose\n  // sockjs to clients that want to use raw websockets\n  _redirectWebsocketEndpoint: function () {\n    var self = this;\n    // Unfortunately we can't use a connect middleware here since\n    // sockjs installs itself prior to all existing listeners\n    // (meaning prior to any connect middlewares) so we need to take\n    // an approach similar to overshadowListeners in\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n    _.each(['request', 'upgrade'], function (event) {\n      var httpServer = WebApp.httpServer;\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);\n      httpServer.removeAllListeners(event);\n\n      // request and upgrade have different arguments passed but\n      // we only care about the first one which is always request\n      var newListener = function (request /*, moreArguments */) {\n        // Store arguments for use within the closure below\n        var args = arguments;\n\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\n        // preserving query string.\n        var parsedUrl = url.parse(request.url);\n        if (parsedUrl.pathname === pathPrefix + '/websocket' || parsedUrl.pathname === pathPrefix + '/websocket/') {\n          parsedUrl.pathname = self.prefix + '/websocket';\n          request.url = url.format(parsedUrl);\n        }\n        _.each(oldHttpServerListeners, function (oldListener) {\n          oldListener.apply(httpServer, args);\n        });\n      };\n      httpServer.addListener(event, newListener);\n    });\n  }\n});","ast":null,"map":{"version":3,"sources":["/stream_server.js"],"names":[],"mappings":"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","file":"/stream_server.js.map","sourcesContent":["var url = Npm.require('url');\n\n// By default, we use the permessage-deflate extension with default\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid\n// JSON. If it represents a falsey value, then we do not use permessage-deflate\n// at all; otherwise, the JSON value is used as an argument to deflate's\n// configure method; see\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md\n//\n// (We do this in an _.once instead of at startup, because we don't want to\n// crash the tool during isopacket load if your JSON doesn't parse. This is only\n// a problem because the tool has to load the DDP server code just in order to\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)\nvar websocketExtensions = _.once(function () {\n  var extensions = [];\n\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION\n        ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {\n    extensions.push(Npm.require('permessage-deflate').configure(\n      websocketCompressionConfig\n    ));\n  }\n\n  return extensions;\n});\n\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX ||  \"\";\n\nStreamServer = function () {\n  var self = this;\n  self.registration_callbacks = [];\n  self.open_sockets = [];\n\n  // Because we are installing directly onto WebApp.httpServer instead of using\n  // WebApp.app, we have to process the path prefix ourselves.\n  self.prefix = pathPrefix + '/sockjs';\n  RoutePolicy.declare(self.prefix + '/', 'network');\n\n  // set up sockjs\n  var sockjs = Npm.require('sockjs');\n  var serverOptions = {\n    prefix: self.prefix,\n    log: function() {},\n    // this is the default, but we code it explicitly because we depend\n    // on it in stream_client:HEARTBEAT_TIMEOUT\n    heartbeat_delay: 45000,\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\n    // bound for that much time, SockJS might not notice that the user has\n    // reconnected because the timer (of disconnect_delay ms) can fire before\n    // SockJS processes the new connection. Eventually we'll fix this by not\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\n    // converts to Unix sockets) but for now, raise the delay.\n    disconnect_delay: 60 * 1000,\n    // Set the USE_JSESSIONID environment variable to enable setting the\n    // JSESSIONID cookie. This is useful for setting up proxies with\n    // session affinity.\n    jsessionid: !!process.env.USE_JSESSIONID\n  };\n\n  // If you know your server environment (eg, proxies) will prevent websockets\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\n  // browsers) will not waste time attempting to use them.\n  // (Your server will still have a /websocket endpoint.)\n  if (process.env.DISABLE_WEBSOCKETS) {\n    serverOptions.websocket = false;\n  } else {\n    serverOptions.faye_server_options = {\n      extensions: websocketExtensions()\n    };\n  }\n\n  self.server = sockjs.createServer(serverOptions);\n\n  // Install the sockjs handlers, but we want to keep around our own particular\n  // request handler that adjusts idle timeouts while we have an outstanding\n  // request.  This compensates for the fact that sockjs removes all listeners\n  // for \"request\" to add its own.\n  WebApp.httpServer.removeListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n  self.server.installHandlers(WebApp.httpServer);\n  WebApp.httpServer.addListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n\n  // Support the /websocket endpoint\n  self._redirectWebsocketEndpoint();\n\n  self.server.on('connection', function (socket) {\n    socket.send = function (data) {\n      socket.write(data);\n    };\n    socket.on('close', function () {\n      self.open_sockets = _.without(self.open_sockets, socket);\n    });\n    self.open_sockets.push(socket);\n\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which\n    // will force old clients to reload. Remove this once we're not\n    // concerned about people upgrading from a pre-0.7.0 release. Also,\n    // remove the clause in the client that ignores the welcome message\n    // (livedata_connection.js)\n    socket.send(JSON.stringify({server_id: \"0\"}));\n\n    // call all our callbacks when we get a new socket. they will do the\n    // work of setting up handlers and such for specific messages.\n    _.each(self.registration_callbacks, function (callback) {\n      callback(socket);\n    });\n  });\n\n};\n\n_.extend(StreamServer.prototype, {\n  // call my callback when a new socket connects.\n  // also call it for all current connections.\n  register: function (callback) {\n    var self = this;\n    self.registration_callbacks.push(callback);\n    _.each(self.all_sockets(), function (socket) {\n      callback(socket);\n    });\n  },\n\n  // get a list of all sockets\n  all_sockets: function () {\n    var self = this;\n    return _.values(self.open_sockets);\n  },\n\n  // Redirect /websocket to /sockjs/websocket in order to not expose\n  // sockjs to clients that want to use raw websockets\n  _redirectWebsocketEndpoint: function() {\n    var self = this;\n    // Unfortunately we can't use a connect middleware here since\n    // sockjs installs itself prior to all existing listeners\n    // (meaning prior to any connect middlewares) so we need to take\n    // an approach similar to overshadowListeners in\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n    _.each(['request', 'upgrade'], function(event) {\n      var httpServer = WebApp.httpServer;\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);\n      httpServer.removeAllListeners(event);\n\n      // request and upgrade have different arguments passed but\n      // we only care about the first one which is always request\n      var newListener = function(request /*, moreArguments */) {\n        // Store arguments for use within the closure below\n        var args = arguments;\n\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\n        // preserving query string.\n        var parsedUrl = url.parse(request.url);\n        if (parsedUrl.pathname === pathPrefix + '/websocket' ||\n            parsedUrl.pathname === pathPrefix + '/websocket/') {\n          parsedUrl.pathname = self.prefix + '/websocket';\n          request.url = url.format(parsedUrl);\n        }\n        _.each(oldHttpServerListeners, function(oldListener) {\n          oldListener.apply(httpServer, args);\n        });\n      };\n      httpServer.addListener(event, newListener);\n    });\n  }\n});\n"]},"hash":"72246e57b2669c10ea60a64e4cd5f3f87b202c20"}
