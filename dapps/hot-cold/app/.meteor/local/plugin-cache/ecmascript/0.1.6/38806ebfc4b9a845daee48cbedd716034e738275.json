{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable();\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    var self = this;\n\n    if (self.retired) return { committed: function () {} };\n\n    if (self.fired) throw new Error(\"fence has already activated -- too late to add writes\");\n\n    self.outstanding_writes++;\n    var committed = false;\n    return {\n      committed: function () {\n        if (committed) throw new Error(\"committed called twice on the same write\");\n        committed = true;\n        self.outstanding_writes--;\n        self._maybeFire();\n      }\n    };\n  },\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    var self = this;\n    if (self === DDPServer._CurrentWriteFence.get()) throw Error(\"Can't arm the current fence\");\n    self.armed = true;\n    self._maybeFire();\n  },\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function (func) {\n    var self = this;\n    if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n    self.before_fire_callbacks.push(func);\n  },\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function (func) {\n    var self = this;\n    if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n    self.completion_callbacks.push(func);\n  },\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    var self = this;\n    var future = new Future();\n    self.onAllCommitted(function () {\n      future['return']();\n    });\n    self.arm();\n    future.wait();\n  },\n\n  _maybeFire: function () {\n    var self = this;\n    if (self.fired) throw new Error(\"write fence already activated?\");\n    if (self.armed && !self.outstanding_writes) {\n      function invokeCallback(func) {\n        try {\n          func(self);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      }\n\n      self.outstanding_writes++;\n      while (self.before_fire_callbacks.length > 0) {\n        var callbacks = self.before_fire_callbacks;\n        self.before_fire_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n      self.outstanding_writes--;\n\n      if (!self.outstanding_writes) {\n        self.fired = true;\n        var callbacks = self.completion_callbacks;\n        self.completion_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n    }\n  },\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    var self = this;\n    if (!self.fired) throw new Error(\"Can't retire a fence that hasn't fired.\");\n    self.retired = true;\n  }\n});","ast":null,"map":{"version":3,"sources":["/writefence.js"],"names":[],"mappings":"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","file":"/writefence.js.map","sourcesContent":["var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    var self = this;\n\n    if (self.retired)\n      return { committed: function () {} };\n\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to add writes\");\n\n    self.outstanding_writes++;\n    var committed = false;\n    return {\n      committed: function () {\n        if (committed)\n          throw new Error(\"committed called twice on the same write\");\n        committed = true;\n        self.outstanding_writes--;\n        self._maybeFire();\n      }\n    };\n  },\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    var self = this;\n    if (self === DDPServer._CurrentWriteFence.get())\n      throw Error(\"Can't arm the current fence\");\n    self.armed = true;\n    self._maybeFire();\n  },\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.before_fire_callbacks.push(func);\n  },\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.completion_callbacks.push(func);\n  },\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    var self = this;\n    var future = new Future;\n    self.onAllCommitted(function () {\n      future['return']();\n    });\n    self.arm();\n    future.wait();\n  },\n\n  _maybeFire: function () {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"write fence already activated?\");\n    if (self.armed && !self.outstanding_writes) {\n      function invokeCallback (func) {\n        try {\n          func(self);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      }\n\n      self.outstanding_writes++;\n      while (self.before_fire_callbacks.length > 0) {\n        var callbacks = self.before_fire_callbacks;\n        self.before_fire_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n      self.outstanding_writes--;\n\n      if (!self.outstanding_writes) {\n        self.fired = true;\n        var callbacks = self.completion_callbacks;\n        self.completion_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n    }\n  },\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    var self = this;\n    if (! self.fired)\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\n    self.retired = true;\n  }\n});\n"]},"hash":"38806ebfc4b9a845daee48cbedd716034e738275"}
