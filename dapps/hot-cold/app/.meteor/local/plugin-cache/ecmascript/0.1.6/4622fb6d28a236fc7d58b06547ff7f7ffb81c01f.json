{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"ReactiveDict._migratedDictData = {}; // name -> data\nReactiveDict._dictsToMigrate = {}; // name -> ReactiveDict\n\nReactiveDict._loadMigratedDict = function (dictName) {\n  if (_.has(ReactiveDict._migratedDictData, dictName)) return ReactiveDict._migratedDictData[dictName];\n\n  return null;\n};\n\nReactiveDict._registerDictForMigrate = function (dictName, dict) {\n  if (_.has(ReactiveDict._dictsToMigrate, dictName)) throw new Error(\"Duplicate ReactiveDict name: \" + dictName);\n\n  ReactiveDict._dictsToMigrate[dictName] = dict;\n};\n\nif (Meteor.isClient && Package.reload) {\n  // Put old migrated data into ReactiveDict._migratedDictData,\n  // where it can be accessed by ReactiveDict._loadMigratedDict.\n  var migrationData = Package.reload.Reload._migrationData('reactive-dict');\n  if (migrationData && migrationData.dicts) ReactiveDict._migratedDictData = migrationData.dicts;\n\n  // On migration, assemble the data from all the dicts that have been\n  // registered.\n  Package.reload.Reload._onMigrate('reactive-dict', function () {\n    var dictsToMigrate = ReactiveDict._dictsToMigrate;\n    var dataToMigrate = {};\n\n    for (var dictName in babelHelpers.sanitizeForInObject(dictsToMigrate)) dataToMigrate[dictName] = dictsToMigrate[dictName]._getMigrationData();\n\n    return [true, { dicts: dataToMigrate }];\n  });\n}","ast":null,"map":{"version":3,"sources":["/migration.js"],"names":[],"mappings":"AAAA,YAAY,CAAC,iBAAiB,GAAG,EAAE,CAAC;AACpC,YAAY,CAAC,eAAe,GAAG,EAAE,CAAC;;AAElC,YAAY,CAAC,iBAAiB,GAAG,UAAU,QAAQ,EAAE;AACnD,MAAI,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,iBAAiB,EAAE,QAAQ,CAAC,EACjD,OAAO,YAAY,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;;AAElD,SAAO,IAAI,CAAC;CACb,CAAC;;AAEF,YAAY,CAAC,uBAAuB,GAAG,UAAU,QAAQ,EAAE,IAAI,EAAE;AAC/D,MAAI,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,eAAe,EAAE,QAAQ,CAAC,EAC/C,MAAM,IAAI,KAAK,CAAC,+BAA+B,GAAG,QAAQ,CAAC,CAAC;;AAE9D,cAAY,CAAC,eAAe,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;CAC/C,CAAC;;AAEF,IAAI,MAAM,CAAC,QAAQ,IAAI,OAAO,CAAC,MAAM,EAAE;;;AAGrC,MAAI,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;AAC1E,MAAI,aAAa,IAAI,aAAa,CAAC,KAAK,EACtC,YAAY,CAAC,iBAAiB,GAAG,aAAa,CAAC,KAAK,CAAC;;;;AAIvD,SAAO,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,eAAe,EAAE,YAAY;AAC5D,QAAI,cAAc,GAAG,YAAY,CAAC,eAAe,CAAC;AAClD,QAAI,aAAa,GAAG,EAAE,CAAC;;AAEvB,SAAK,IAAI,QAAQ,qCAAI,cAAc,GACjC,aAAa,CAAC,QAAQ,CAAC,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC,iBAAiB,EAAE,CAAC;;AAEzE,WAAO,CAAC,IAAI,EAAE,EAAC,KAAK,EAAE,aAAa,EAAC,CAAC,CAAC;GACvC,CAAC,CAAC;CACJ","file":"/migration.js.map","sourcesContent":["ReactiveDict._migratedDictData = {}; // name -> data\nReactiveDict._dictsToMigrate = {}; // name -> ReactiveDict\n\nReactiveDict._loadMigratedDict = function (dictName) {\n  if (_.has(ReactiveDict._migratedDictData, dictName))\n    return ReactiveDict._migratedDictData[dictName];\n\n  return null;\n};\n\nReactiveDict._registerDictForMigrate = function (dictName, dict) {\n  if (_.has(ReactiveDict._dictsToMigrate, dictName))\n    throw new Error(\"Duplicate ReactiveDict name: \" + dictName);\n\n  ReactiveDict._dictsToMigrate[dictName] = dict;\n};\n\nif (Meteor.isClient && Package.reload) {\n  // Put old migrated data into ReactiveDict._migratedDictData,\n  // where it can be accessed by ReactiveDict._loadMigratedDict.\n  var migrationData = Package.reload.Reload._migrationData('reactive-dict');\n  if (migrationData && migrationData.dicts)\n    ReactiveDict._migratedDictData = migrationData.dicts;\n\n  // On migration, assemble the data from all the dicts that have been\n  // registered.\n  Package.reload.Reload._onMigrate('reactive-dict', function () {\n    var dictsToMigrate = ReactiveDict._dictsToMigrate;\n    var dataToMigrate = {};\n\n    for (var dictName in dictsToMigrate)\n      dataToMigrate[dictName] = dictsToMigrate[dictName]._getMigrationData();\n\n    return [true, {dicts: dataToMigrate}];\n  });\n}\n"]},"hash":"4622fb6d28a236fc7d58b06547ff7f7ffb81c01f"}
