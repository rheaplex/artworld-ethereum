{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n\n_.extend(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function (msg) {\n    var self = this;\n    if (!_.has(msg, 'collection')) {\n      return '';\n    } else if (typeof msg.collection === 'string') {\n      if (msg.collection === '') throw Error(\"Message has empty collection!\");\n      return msg.collection;\n    } else {\n      throw Error(\"Message has non-string collection!\");\n    }\n  },\n\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n\n    var collection = self._collectionForMessage(trigger);\n    var record = { trigger: EJSON.clone(trigger), callback: callback };\n    if (!_.has(self.listenersByCollection, collection)) {\n      self.listenersByCollection[collection] = {};\n    }\n    self.listenersByCollection[collection][id] = record;\n\n    if (self.factName && Package.facts) {\n      Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, 1);\n    }\n\n    return {\n      stop: function () {\n        if (self.factName && Package.facts) {\n          Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, -1);\n        }\n        delete self.listenersByCollection[collection][id];\n        if (_.isEmpty(self.listenersByCollection[collection])) {\n          delete self.listenersByCollection[collection];\n        }\n      }\n    };\n  },\n\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: function (notification) {\n    var self = this;\n\n    var collection = self._collectionForMessage(notification);\n\n    if (!_.has(self.listenersByCollection, collection)) {\n      return;\n    }\n\n    var listenersForCollection = self.listenersByCollection[collection];\n    var callbackIds = [];\n    _.each(listenersForCollection, function (l, id) {\n      if (self._matches(notification, l.trigger)) {\n        callbackIds.push(id);\n      }\n    });\n\n    // Listener callbacks can yield, so we need to first find all the ones that\n    // match in a single iteration over self.listenersByCollection (which can't\n    // be mutated during this iteration), and then invoke the matching\n    // callbacks, checking before each call to ensure they haven't stopped.\n    // Note that we don't have to check that\n    // self.listenersByCollection[collection] still === listenersForCollection,\n    // because the only way that stops being true is if listenersForCollection\n    // first gets reduced down to the empty object (and then never gets\n    // increased again).\n    _.each(callbackIds, function (id) {\n      if (_.has(listenersForCollection, id)) {\n        listenersForCollection[id].callback(notification);\n      }\n    });\n  },\n\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function (notification, trigger) {\n    // Most notifications that use the crossbar have a string `collection` and\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and\n    // avoid the overly generic EJSON.equals). This makes a noticeable\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\n    if (typeof notification.id === 'string' && typeof trigger.id === 'string' && notification.id !== trigger.id) {\n      return false;\n    }\n    if (notification.id instanceof MongoID.ObjectID && trigger.id instanceof MongoID.ObjectID && !notification.id.equals(trigger.id)) {\n      return false;\n    }\n\n    return _.all(trigger, function (triggerValue, key) {\n      return !_.has(notification, key) || EJSON.equals(triggerValue, notification[key]);\n    });\n  }\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});","ast":null,"map":{"version":3,"sources":["/crossbar.js"],"names":[],"mappings":"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","file":"/crossbar.js.map","sourcesContent":["// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n\n_.extend(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function (msg) {\n    var self = this;\n    if (! _.has(msg, 'collection')) {\n      return '';\n    } else if (typeof(msg.collection) === 'string') {\n      if (msg.collection === '')\n        throw Error(\"Message has empty collection!\");\n      return msg.collection;\n    } else {\n      throw Error(\"Message has non-string collection!\");\n    }\n  },\n\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n\n    var collection = self._collectionForMessage(trigger);\n    var record = {trigger: EJSON.clone(trigger), callback: callback};\n    if (! _.has(self.listenersByCollection, collection)) {\n      self.listenersByCollection[collection] = {};\n    }\n    self.listenersByCollection[collection][id] = record;\n\n    if (self.factName && Package.facts) {\n      Package.facts.Facts.incrementServerFact(\n        self.factPackage, self.factName, 1);\n    }\n\n    return {\n      stop: function () {\n        if (self.factName && Package.facts) {\n          Package.facts.Facts.incrementServerFact(\n            self.factPackage, self.factName, -1);\n        }\n        delete self.listenersByCollection[collection][id];\n        if (_.isEmpty(self.listenersByCollection[collection])) {\n          delete self.listenersByCollection[collection];\n        }\n      }\n    };\n  },\n\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: function (notification) {\n    var self = this;\n\n    var collection = self._collectionForMessage(notification);\n\n    if (! _.has(self.listenersByCollection, collection)) {\n      return;\n    }\n\n    var listenersForCollection = self.listenersByCollection[collection];\n    var callbackIds = [];\n    _.each(listenersForCollection, function (l, id) {\n      if (self._matches(notification, l.trigger)) {\n        callbackIds.push(id);\n      }\n    });\n\n    // Listener callbacks can yield, so we need to first find all the ones that\n    // match in a single iteration over self.listenersByCollection (which can't\n    // be mutated during this iteration), and then invoke the matching\n    // callbacks, checking before each call to ensure they haven't stopped.\n    // Note that we don't have to check that\n    // self.listenersByCollection[collection] still === listenersForCollection,\n    // because the only way that stops being true is if listenersForCollection\n    // first gets reduced down to the empty object (and then never gets\n    // increased again).\n    _.each(callbackIds, function (id) {\n      if (_.has(listenersForCollection, id)) {\n        listenersForCollection[id].callback(notification);\n      }\n    });\n  },\n\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function (notification, trigger) {\n    // Most notifications that use the crossbar have a string `collection` and\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and\n    // avoid the overly generic EJSON.equals). This makes a noticeable\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\n    if (typeof(notification.id) === 'string' &&\n        typeof(trigger.id) === 'string' &&\n        notification.id !== trigger.id) {\n      return false;\n    }\n    if (notification.id instanceof MongoID.ObjectID &&\n        trigger.id instanceof MongoID.ObjectID &&\n        ! notification.id.equals(trigger.id)) {\n      return false;\n    }\n\n    return _.all(trigger, function (triggerValue, key) {\n      return !_.has(notification, key) ||\n        EJSON.equals(triggerValue, notification[key]);\n    });\n  }\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});\n"]},"hash":"958ed229abb44776323cd6c1d03a5c7b5553250c"}
